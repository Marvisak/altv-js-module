const fs = require('fs');
const execSync = require('child_process').execSync;

let defsFilepath = "BUILD/utils/altv-server.d.ts";
let jsonFilepath = "BUILD/utils/altv-server.json";

module.exports.args = [
  // Files to parse

  "../src/helpers/bindings/Vector3.cpp",
  "../src/helpers/bindings/WorldObject.cpp",
  "../src/helpers/bindings/Entity.cpp",
  "../src/helpers/bindings/BaseObject.cpp",

  "../src/bindings/Blip.cpp",
  "../src/bindings/VoiceChannel.cpp",
  "../src/bindings/Vehicle.cpp",
  "../src/bindings/Player.cpp",
  "../src/bindings/Main.cpp",
  "../src/bindings/Checkpoint.cpp",
  "../src/bindings/ColShape.cpp",

  "--",

  // Includes
  "-I../src/",
  "-I../src/cpp-sdk/",
  "-I../src/helpers/",
  "-I../deps/nodejs/include/",
  "-I../deps/nodejs/deps/v8/include/",
  "-I../deps/nodejs/deps/uv/include/",

  // Defines
  "-DUNICODE",
  "-D_UNICODE",
  "-DCXX_COMPILER_ID=\"\"",
  "-DXXH_INLINE_ALL",

  // Clang stuff
  "-fms-compatibility",
  "-fms-extensions",

  "-Wno-deprecated-declarations",
  "-Wno-switch-enum",
  "-Wno-unused-command-line-argument",
  "-Wno-macro-redefined",
  "-Wno-inconsistent-missing-override",
  "-Wno-deprecated-declarations",
  "-Wno-return-type",
  "-Wno-switch-enum",
  "-Wno-switch",
  "-Wno-parentheses",
  "-Wno-unused-private-field",
  "-Wno-unused-variable",
  "-Wno-format",
  "-Wno-reorder",
  "-Wno-delete-non-virtual-dtor",
  "-Wno-microsoft-cast",
  "-Wno-unused-function",
  "-Wno-unused-lambda-capture",
  "-Wno-missing-braces",
  "-Wno-unused-local-typedef",
  "-Wno-tautological-constant-out-of-range-compare",
  "-Wno-delete-incomplete",
  "-Wno-c++11-narrowing",
  "-Wno-comment",

  "-xc++",
  "-ferror-limit=0",
  "-Wno-pragma-once-outside-header",
  "-std=c++17",
  "-Wno-switch-enum",
  "-Wno-switch",

  "-fparse-all-comments",
].join(" ")

tsTypes = {
  Boolean: 'boolean',
  Number: 'number',
  String: 'string',
  Null: 'null',

  Integer: 'number',
  Int32: 'number',
  Uint32: 'number',
  Primitive: 'null',
  Value: 'any',
  int: 'number',
  float: 'number',
  Vector3Native: 'altmath.vec3',
  Vector3NativePtr: 'Vector3Native',
  charPtr: 'string',
  _BoolPtr: 'boolean',
  intPtr: 'number',
  floatPtr: 'float',

  // C++/Clang Types
  _Bool: 'boolean',
};

function createdir(path) {
  if (!fs.existsSync(path))
    fs.mkdirSync(path, {
      recursive: true
    });
}

function getType(type) {
  let t = type
    .replace(/Array$/g, 'Array<any>')
    .replace(/struct /g, '')
    .replace(/unsigned /g, '')
    .replace(/ \*|\*/g, 'Ptr');

  if (tsTypes[t] != undefined) {
    return tsTypes[t];
  } else return t;
}

module.exports.genTypescript = () => {
  let json = JSON.parse(fs.readFileSync('BUILD/altv-client.json'));

  console.log("Creating Typescript Definitions");

  let ts =
    `
// THIS FILE IS AUTOGENERATED
// Generated on "${new Date().toLocaleString()}"
`

  for (const modulename in json.modules) {
    if (!json.modules.hasOwnProperty(modulename)) continue;
    if(modulename == 'natives') continue;
    const module = json.modules[modulename]

    ts += `\ndeclare module "${modulename}" {`

    function processAccessors(accessors, indent, prefix = "") {
      for (const accessorname in accessors) {
        if (!accessors.hasOwnProperty(accessorname)) continue
        const accessor = accessors[accessorname];

        let types = ""
        if (accessor.types != null) {
          let accessortypes = [...new Set(accessor.types)]
          accessortypes.forEach((type, i) => {
            types += getType(type)
            if (i != accessortypes.length - 1) types += "|"
          });
        }
        if (types == "") types = "any"

        // let comment = ""
        let readonly = true
        if (accessor.getter) {
          if (accessor.getter.comment != null && accessor.getter.comment.raw != "") {
            // comment += accessor.getter.comment.raw
            //   .replace(/\/\*\*/g, `$&\nGetter:`)
            //   .replace(/(\n)/g, `$&${indent}${indent}`)
          }
        }

        if (accessor.setter) {
          readonly = false
          // comment += comment.replace(
          //   /\/\*/g,
          //   accessor.setter.comment.raw
          //   .replace(/\/\*\*/g, `$&\nSetter:`)
          //   .replace(/(\n)/g, `$&${indent}${indent}`)
          // )
        }

        // if (comment != "")
        //   ts += `\n${indent}${comment}\n`
        
        let qualifiers = `${accessor.static ? "static " : ""}${readonly ? "readonly " : ""}`
        ts += `${indent}${qualifiers}${prefix}${accessorname}: ${types};\n`
      }

      ts += "\n"
    }

    function processParam(params, paraminfo, prefix = "", suffix = "") {
      let types = ""
      if (paraminfo.types != null) {
        let paramtypes = [...new Set(paraminfo.types)]
        paramtypes.forEach((type, i) => {
          types += getType(type)
          if (i != paramtypes.length - 1) types += "|"
        });
      }
      if (types == "") types = "any"

      let paramname = types.includes("Function") ?
        paraminfo.name + "Fn" : paraminfo.name

      params += `${prefix}${paramname}: ${types}${suffix}`

      return params
    }

    function processParams(paramsjson)
    {
      let params = ""

      for (const paramindex in paramsjson) {
        if (!paramsjson.hasOwnProperty(paramindex) ||
          paramindex == "rest")
          continue
        const paraminfo = paramsjson[paramindex];

        params = processParam(params, paraminfo)

        if (paramsjson[parseInt(paramindex) + 1] != null) params += ", "
      }
      if (paramsjson != null && paramsjson["rest"]) {
        if (params.length != 0) params += ", "
        params = processParam(params, paramsjson["rest"], "...", "[]")
      }

      return params
    }

    function processFunctions(functions, indent, prefix = "") {
      for (const functionname in functions) {
        if (!functions.hasOwnProperty(functionname)) continue
        const functioninfo = functions[functionname];

        /*if (functioninfo.comment != null && functioninfo.comment.raw != "") {
          let comment = indent + functioninfo.comment.raw
            .replace(/(\n)/g, `$&${indent}${indent}`)
          ts += `\n${comment}\n`
        }*/

        // params
        let params = processParams(functioninfo.params);

        // return types
        let returns = ""
        if (functioninfo.returns != null) {
          let returntypes = [...new Set(functioninfo.returns)]
          returntypes.forEach((type, i) => {
            if (type instanceof Array) {
              returns += '['
              type.forEach((arraytype, j) => {
                returns += getType(arraytype)
                if (j != type.length - 1) returns += ", "
              });
              returns += ']'
            } else
              returns += getType(type)
            if (i != returntypes.length - 1) returns += "|"
          });
        }
        if (returns == "") returns = "void"

        ts += `${indent}${prefix}${functionname}(${params}): ${returns};\n`
      }
    }

    function processConstructors(constructors, indent, prefix = "")
    {
      for (const ctorindex in constructors)
      {
        if (!constructors.hasOwnProperty(ctorindex)) continue
        const ctor = constructors[ctorindex];

        // params
        let params = processParams(ctor.params)

        ts += `${indent}${prefix}constructor(${params});\n`
      }
    }

    function processFields(fields, indent, prefix = "")
    {
      if(!fields)
        return;

        for (const fieldname in fields) {
          if (!fields.hasOwnProperty(fieldname)) continue
          const fieldinfo = fields[fieldname];
          let fieldtypes = ""

          if(fieldinfo.types)
          {
            fieldinfo.types.forEach(type => {
              if(fieldtypes!="")
                fieldtypes+="|"

              fieldtypes+=type
            });
          }
          else
            fieldtypes = "any"

          ts += `${indent}${fieldname}: ${fieldtypes};\n`
        }
    }

    // module classes
    let processedclasses = []
    let moduleclasses = [...new Set(module.classes)]
    for (const moduleclass in moduleclasses) {
      if (!module.classes.hasOwnProperty(moduleclass)) continue
      const classname = module.classes[moduleclass];

      if (processedclasses.includes(classname)) continue
      processedclasses.push(classname)

      const classinfo = json.classes[classname];
      if(classinfo == undefined) {
        console.error("Unknown classname", classname)
        continue
      }

      // Class Parent
      let parent = classinfo.parent
      let parentValid = parent != null && parent != ""

      function handleParent(parent) {
        let parentinfo
        if (parent != undefined && parent != "" && !processedclasses.includes(parent)) {
          processedclasses.push(parent)
          parentinfo = json.classes[parent];
          let parentValid = parentinfo.parent != null && parentinfo.parent != ""

          ts +=
            `
  export class ${parent}${parentValid ? " extends "+parentinfo.parent : ""} {\n`
          processFields(parentinfo.fields, "    ")
          processAccessors(parentinfo.accessors, "    ")
          processFunctions(parentinfo.functions, "    ")
          ts += `  }\n`
        }
        if (parentinfo != null) handleParent(parentinfo.parent)
      }
      handleParent(parent)

      // Class
      ts +=
        `
  export class ${classname}${parentValid ? " extends "+parent : ""} {\n`
      processFields(classinfo.fields, "    ")
      processAccessors(classinfo.accessors, "    ")
      processConstructors(classinfo.constructors, "    ")
      processFunctions(classinfo.functions, "    ")
      ts += `  }\n`
    }
    ts += "\n"

    //processFields(module.fields, "  ")
    processAccessors(module.accessors, "  ", "var ")
    processFunctions(module.functions, "  ", "export function ")

    ts += `}\n`
  }

  // output ts
  createdir("BUILD/utils")
  fs.writeFileSync(defsFilepath, ts)
  fs.copyFileSync("BUILD/altv-client.json", jsonFilepath)

  console.log("Output typescript definitions to "+defsFilepath)
}

((...args) => {
  console.log('Processing client JS bindings \n');
  try {
    createdir('BUILD')
    execSync(`"${__dirname}/altv-v8-tool" ${exports.args}`, {
      cwd: 'BUILD',
      stdio: 'inherit'
    });
  } catch (error) {
    throw error
  }
  console.log('Done processing clientjs bindings');

  exports.genTypescript()
})();
